- [4-1 ALU와 제어장치](#4-1-alu와-제어장치)
  - [ALU](#alu)
  - [제어장치](#제어장치)
- [4-2 레지스터](#4-2-레지스터)
    - [특정 레지스터를 이용한 주소 지정 방식(1): 스택 주소 지정 방식](#특정-레지스터를-이용한-주소-지정-방식1-스택-주소-지정-방식)
    - [특정 레지스터를 이용한 주소 지정 방식(2): 변위 주소 지정 방식](#특정-레지스터를-이용한-주소-지정-방식2-변위-주소-지정-방식)
      - [상대 주소 지정 방식](#상대-주소-지정-방식)
      - [베이스 레지스터 주소 지정 방식](#베이스-레지스터-주소-지정-방식)
- [4-3 명령어 사이클과 인터럽트](#4-3-명령어-사이클과-인터럽트)
  - [명령어 사이클](#명령어-사이클)
  - [인터럽트](#인터럽트)
    - [하드웨어 인터럽트](#하드웨어-인터럽트)
    - [하드웨어 인터럽트 처리 순서](#하드웨어-인터럽트-처리-순서)


# 4-1 ALU와 제어장치

## ALU
![ALU](image.png)
- ALU가 받아들이는 정보: 피연산자(from 레지스터), 제어신호(수행할 연산. from 제어장치)
- ALU가 내보내는 정보: 연산 수행 결과(특정 숫자/문자/메모리 주소. 메모리가 아닌 레지스터에 일시적으로 저장됨), 플래그

**ALU가 내보내는 대표적인 플래그(flag)**\
![flag](image-1.png)\
: CPU가 프로그램을 실행하는 도중 반드시 기억해야 하는 일종의 참고 정보.\
**플래그 레지스터**라는 레지스터에 저장됨.
|연산 결과가 음수임을 알 수 있음|연산 결과가 0임을 알 수 있음|
|:---:|:---:|
|![부호 플래그](image-2.png)|![제로 플래그](image-3.png)|

## 제어장치
제어장치: 제어 신호를 내보내고 명령어를 해석하는 부품\
제어 신호: 컴퓨터 부품들을 관리하고 작동시키기 위한 일종의 전기 신호
![제어장치](image-4.png)
- 받아들이는 정보
   1. 클럭(clock)\
      : 컴퓨터의 모든 부품을 움직일 수 있게 하는 시간 단위. 클럭의 주기에 맞춰 작동함(주의: 부품이 클럭 박자에 맞춰 작동하는 것이지 한 클럭마다 작동한다는 것이 아님.)\
      ![클럭](image-5.png)
   2. 해석해야 할 명령어\
      : 명령어 레지스터에 저장됨. 명령어 레지스터로부터 해석할 명령어를 받아들이고 해석한 뒤, 제어 신호를 발생시켜 컴퓨터 부품들이 수행해야 할 내용을 알려줌
   3. 플래그 레지스터 속 플래그 값
   4. 시스템 버스 중 제어 버스로 전달된 제어 신호\
      제어 버스를 통해 외부로부터 전달된 제어신호를 받아들이기도 함

- 내보내는 정보: CPU 외부에 전달하는 제어신호(메모리에 전달하는 제어신호, 입출력장치(보조기억장치 포함)에 전달하는 제어 신호), CPU 내부에 전달하는 제어신호

# 4-2 레지스터
알아야 할 대표적인 레지스터\
![레지스터](image-6.png)

1. 프로그램 카운터\
   메모리에서 가져올 명령어의 주소를 저장. '명령어 포인터'라고 부르는 CPU도 있음

2. 명령어 레지스터\
   해석할 명령어, 즉 방금 메모리에서 읽어 들인 명령어를 저장하는 레지스터

3. 메모리 주소 레지스터\
   메모리의 주소를 저장하는 레지스터(ex: CPU가 읽어 들이고자 하는 주소 값을 주소 버스로 보낼 때 메모리 주소 레지스터를 거치게 됨)

4. 메모리 버터 레지스터\
   메모리와 주고 받을 값(데이터와 명령어)을 저장하는 레지스터. 메모리에 쓰고 싶은 값이나 메모리로부터 전달받은 값은 메모리 버퍼 레지스터를 거침

![alt text](image-7.png)
![alt text](image-8.png)
![alt text](image-9.png)
![alt text](image-10.png)

CPU 속 프로그램 카운터가 꾸준히 증가하기 때문에 CPU가 메모리 속 프로그램을 순차적으로 읽어 들이고 실행해 나갈 수 있음.
![alt text](image-11.png)

5. 범용 레지스터\
   다양하고 일반적인 상황에서 자유롭게 사용할 수 있는 레지스터.\
   메모리 버퍼 레지스터와 메모리 주소 레지스터는 각각 데이터 버스, 주소 버스로 보낼 값만 저장하는 반면 범용 레지스터는 데이터와 주소를 모두 저장할 수 있음

6. 플래그 레지스터\
   ALU 연산 결과에 따른 플래그를 플래그 레지스터에 저장. 연산 결과 또는 CPU 상태에 대한 부가적인 정보를 저장하는 레지스터

### 특정 레지스터를 이용한 주소 지정 방식(1): 스택 주소 지정 방식
7. 스택 포인터\
   스택 주소 지정 방식이라는 주소 지정 방식에 사용되고, 프로그램 카운터와 베이스 레지스터는 변위 주소 지정방식이라는 주소 지정 방식에 사용됨

   - **스택 주소 지정 방식**: 스택과 스택 포인터를 이용한 주소 지정 방식
   - **스택 포인터**: 스택의 꼭대기를 가리키는 레지스터. 즉, 스택에 마지막으로 저장한 값의 위치를 저장하는 레지스터
  
  ex) 스택 포인터: 4번지를 저장함(어디까지 데이터가 채워져 있는지에 대한 표시라고 보면 됨) \
  ![alt text](image-12.png)

  데이터를 꺼낼 경우 1 -> 2 -> 3 순서로 데이터를 꺼낼 수 있음. 만약 하나의 데이터를 꺼냈다면 스택 포인터는 5번지를 가리키고, 후에 하나를 다시 집어넣는다면 스택 포인터는 4번지를 가리키게 됨

스택 영역: 메모리 안에 스택처럼 사용하기로 암묵적으로 약속된 영역
![alt text](image-13.png)

### 특정 레지스터를 이용한 주소 지정 방식(2): 변위 주소 지정 방식
변위 주소 지정 방식: 오퍼랜드 필드의 값(변위)과 특정 레지스터의 값을 더하여 유효 주소를 얻어내는 주소 지정 방식\
![alt text](image-14.png)

변위 주소 지정 방식을 사용하는 명령어는 기존 명령어 필드에 어떤 레지스터의 값과 더할지 나타내는 레지스터 필드가 있다는 점에서 차이가 있다.\
![alt text](image-15.png)\
이때 변위 주소 지정 방식은 오퍼랜드 필드의 주소와 어떤 레지스터를 더하는지에 따라 `상대 주소 지정방식`, `베이스 레지스터 주소 지정 방식` 등으로 나뉨

#### 상대 주소 지정 방식
: 오퍼랜드와 프로그램 카운터의 값을 더하여 유효 주소를 얻는 방식

ex) 오퍼랜드가 -3이었다면 CPU는 읽어 들이기로 한 명령어로부터 세 번째 이전 번지로 접근하고, 3이었다면 세 번째 이후 번지로 접근한다.\
![alt text](image-16.png)
![alt text](image-17.png)\
if문과 유사하게 모든 코드를 실행하는 것이 아닌, 분기하여 특정 주소의 코드를 실행할 때 사용된다.

#### 베이스 레지스터 주소 지정 방식
: 오퍼랜드와 베이스 레지스터의 값을 더하여 유효 주소를 얻는 방식

베이스 레지스터는 '기준 주소' 오퍼랜드는 '기준 주소로부터 떨어진 거리' 의 역할을 한다.
ex) 베이스 레지스터에 200이라는 값이 저장되어 있고 오퍼랜드가 50이라면 "기준 주소 200번지로부터 50만큼 떨어진 250번지로 접근하라"를 의미한다.
![alt text](image-18.png)

# 4-3 명령어 사이클과 인터럽트

명령어 사이클: 하나의 명령어를 처리하는 정형화된 흐름
인터럽트: 명령어의 흐름이 끊어지는 상황

## 명령어 사이클
명령어 사이클: 프로그램 속 각각의 명령어들이 반복되어 실행되는 일정한 주기
- 인출 사이클: 메모리에 있는 명령어를 CPU로 가지고 오는 단계
- 실행 사이클: 인출한 명령어를 실행하는 단계_제어장치가 명령어 레지스터에 담긴 값을 해석하고, 제어 신호를 발생시키는 단계

=> 프로그램을 이루는 수많은 명령어는 일반적으로 인출과 실행 사이클을 반복하며 실행됨
![alt text](image-19.png)

- 간접 사이클: 명령어를 인출하여 CPU로 가져왔다 하더라도 바로 실행 사이클에 도입할 수 없는 경우(ex: 간접 주소 지정방식_오퍼랜드 필드에 유효주소의 주소를 명시하므로 명령어를 실행하기 위해서는 메모리 접근을 한 번 더 해야 함)
![alt text](image-20.png)

## 인터럽트
인터럽트: CPU가 수행 중인 작업을 방해하는 신호
"이게 더 급한 거니까 지금 하던 일 멈추고 이것부터 처리해 줘." 라는 요청과 같음

![alt text](image-23.png)\
- 동기 인터럽트(예외): CPU에 의해 발생하는 인터럽트. CPU가 명령어들을 수행하다가 예상치 못한 상황에 마주쳤을 때, 가령 CPU가 실행하는 프로그래밍상의 오류와 같은 예외적인 상황에 마주쳤을 때 발생하는 인터럽트\
![alt text](image-22.png)\
- 비동기 인터럽트(하드웨어 인터럽트): 입출력장치에 의해 발생하는 인터럽트.  세탁기 완료 알림, 전자레인지 조리 완료 알림과 같은 알림 역할을 함\
![alt text](image-24.png)

### 하드웨어 인터럽트
: 알림과 같은 인터럽트. 입출력 작업 도중에도 효율적으로 명령어를 처리하기 위해 이런 알림과 같은 하드웨어 인터럽트를 사용함
(만약 사용하지 않는다면 알림 없는 전자레인지가 언제 조리를 끝낼지 모르는 채 무작정 전자레인지 앞에서 서성이는 셈)

### 하드웨어 인터럽트 처리 순서
1. 입출력장치는 CPU에 `인터럽트 요청 신호`를 보낸다.
2. CPU는 실행 사이클이 끝나고 명령어를 인출하기 전 항상 인터럽트 여부를 확인한다.
3. CPU는 인터럽트 요청을 확인하고 `인터럽트 플래그`를 통해 현재 인터럽트를 받아들일 수 있는지 여부를 확인한다.
4. 인터럽트를 받아들일 수 있다면 CPU는 지금까지의 작업을 백업한다.
5. CPU는 `인터럽트 벡터`를 참조하여 `인터럽트 서비스 루틴`을 실행한다.
6. 인터럽트 서비스 루틴 실행이 끝나면 4에서 백업해 둔 작업을 복구하여 실행을 재개한다.
   
- 인터럽트 요청 신호: 인터럽트 하기 전 "지금 끼어들어도 되나요?"하고 CPU에게 묻는 신호\
![alt text](image-25.png)\
- 인터럽트 플래그: 하드웨어 인터럽트를 받아들일지, 무시할지를 결정하는 플래그.\
  (CPU가 중요한 작업을 처리해야 하거나 어떤 방해도 받지 않아야 할 때 인터럽트 플래그는 불가능으로 설정됨)\
  ![alt text](image-26.png)\
다만, 모든 하드웨어 인터럽트를 인터럽트 플래그로 막을 수 있는 것은 아님. 무시할 수 없는, 즉 가장 우선순위가 높은, 가장 먼저 처리해야하는 인터럽트가 존재\
ex: 정전이나 하드웨어 고장으로 인한 인터럽트\
![alt text](image-27.png)\
- 인터럽트 서비스 루틴(인터럽트 핸들러): 인터럽트를 처리하기 위한 프로그램\
  "키보드가 어떤 요청을 보냈을 때는 어떻게 작동한다", "마우스가 어떤 인터럽트 요청을 보냈을 때는 어떻게 작동한다"와 같이 어떤 인터럽트가 발생했을 때 해당 인터럽트를 어떻게 처리하고 작동해야 할지에 대한 정보로 이루어진 프로그램\
![alt text](image-28.png)

- 인터럽트 벡터: 인터럽트 서비스 루틴을 식별하기 위한 정보. 인터럽트 벡터를 알면 인터럽트 서비스 루틴의 시작 주소를 알 수 있기 때문에 CPU는 인터럽트 벡터를 통해 특정 인터럽트 서비스 루틴을 처음부터 실행할 수 있음
  
![alt text](image-29.png)

'CPU가 인터럽트를 처리한다' === '인터럽트 서비스 루틴을 실행하고, 본래 수행하던 작업으로 다시 되돌아온다.'

인터럽트 서비스 루틴 또한 명령어와 데이터로 이루어져 있음=> 인터럽트 서비스 루틴도 프로그램 카운터를 비롯한 레지스터들을 사용하며 실행 됨

인터럽트 발생 전까지 레지스터에 저장되어 있던 값들은 어떻게 할까?\
![alt text](image-30.png)

CPU는 인터럽트 서비스 루틴을 실행하기 전에 프로그램 카운터 값 등 현재 프로그램을 재개하기 위해 필요한 모든 내용을 스택에 백업한다. 그 후 인터럽트 서비스 루틴의 시작 주소가 위치한 곳으로 프로그램 카운터 값을 갱신하고 인터럽트 서비스 루틴을 실행함\
![alt text](image-31.png)\
인터럽트 서비스 루틴을 모두 실행하면 스택에 저장해 둔 값을 다시 불러온뒤 이전까지 수행하던 작업을 재개함

![alt text](image-32.png)

