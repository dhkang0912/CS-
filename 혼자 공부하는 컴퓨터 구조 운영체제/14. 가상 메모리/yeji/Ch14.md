# Ch14. 가상 메모리
## 목차
- [Ch14. 가상 메모리](#ch14-가상-메모리)
  - [14-1. 연속 메모리 할당](#14-1-연속-메모리-할당)
    - [14-1-1. 스와핑](#14-1-1-스와핑)
    - [14-1-2. 메모리 할당](#14-1-2-메모리-할당)
    - [14-1-3. 외부 단편화](#14-1-3-외부-단편화)
  - [14-2. 페이징을 통한 가상 메모리 관리](#14-2-페이징을-통한-가상-메모리-관리)
    - [14-2-1. 페이징이란](#14-2-1-페이징이란)
    - [14-2-2. 페이지 테이블](#14-2-2-페이지-테이블)
    - [14-2-3. 페이징에서의 주소 변환](#14-2-3-페이징에서의-주소-변환)
    - [14-2-4. 페이지 테이블 엔트리](#14-2-4-페이지-테이블-엔트리)
  - [14-3. 페이지 교체와 프레임 할당](#14-3-페이지-교체와-프레임-할당)
    - [14-3-1. 요구 페이징](#14-3-1-요구-페이징)
    - [14-3-2. 페이지 교체 알고리즘](#14-3-2-페이지-교체-알고리즘)
    - [14-3-3. 스래싱과 프레임 할당](#14-3-3-스래싱과-프레임-할당)
  - [Question](#question)

# 14-1. 연속 메모리 할당
- `연속 메모리 할당` 방식 : 프로세스에 연속적인 메모리 공간 할당하는 방식
- 프로세스들은 메모리에 연속적으로 할당할 때 무엇을 고려하는지, 잠재적 문제는 무엇인지 체크!

## 14-1-1. 스와핑(swapping)
![스와핑](image.png)
- 스와핑: 메모리에서 사용되지 않는 일부 프로세스를 보조 기억 장치로 내보내고 실행할 프로세스를 메모리로 들여보내는 메모리 관리 기법
  - 스왑 영역(swap space): 프로세스들이 쫓겨나는 보조기억장치의 일부 영역
  - 스왑 아웃(swap-out): 현재 실행되지 않는 프로세스가 메모리에서 스왑 영역으로 옮겨지는 것
  - 스왑 인(swap-in): 스왑 영역에 있던 프로세스가 다시 메모리로 옮겨오는 것
  - 스왑 아웃된 프로세스가 다시 스왑 인 될 경우, 이전 물리주소와 다른 주소에 적재 될수도
- 스와핑 이용시, 프로세스들이요구하는 메모리 주소공간 크기가 실제 메모리 크기보다 커도 `프로세스 동시 실행` 가능
  ![스와핑 적재](image-1.png)
- 스왑 영역 확인하기
  - free, top 명령어 등으로 스왑 영역 크기 확인 가능

## 14-1-2. 메모리 할당
- 프로세스는 메모리 내 빈 공간에 적재되어야
- What if? 메모리 내 빈 공간이 여러 개라면?
  비어있는 메모리 공간에 프로세스를 연속적으로 할당 --> 최초 적합, 최적 적합, 최악 적합
  ![메모리 할당](image-2.png)
### 최초 적합(first fit)
- OS가 메모리 내 빈 공간 순서대로 검색하다가 **적재할 수 있는 공간 발견하면 그 공간에** 프로세스 배치
- OS가 빈 공간 A -> B -> C 순으로 검색했다면 프로세스는 빈 공간 A에 적재
- 최초 적합 방식은 프로세스가 적재될 수 있는 공간 발견하는 즉시 메모리 할당하는 방식
- `검색 최소화`할 수 있고 결과적으로 `빠른 할당` 가능
![최초 적합](image-3.png)
### 최적 적합(best fit)
- OS가 빈 공간 모두 검색한 후, 프로세스가 **적재될 수 있는 공간 중 가장 작은 공간**에 프로세스 배치
- 예시에서 가장 작은 빈 공간 C에 할당
![최적 적합](image-4.png)
### 최악 적합(worst fit)
- OS가 빈 공간 모두 검색한 후, 프로세스가 **적재될 수 있는 공간 중 가장 큰 공간**에 프로세스 배치
- 예시에서 가장 큰 빈 공간 B에 할당
![alt text](image-5.png)

## 14-1-3. 외부 단편화(external fragmentation)
- 연속 메모리 할당 메모리 효율적으로 사용하는 방법X
- 연속 메모리 할당은 `외부 단편화 문제 내포`
<table>
<tr>
<td align="center">
    
![alt text](image-6.png)
    
프로세스 아무것도 적재 안 된 상태

</td>
<td align="center">
    
![alt text](image-7.png)
    
사용자 영역에<br> 프로세스 적재

</td>
</tr>
<tr>
<td align="center">
    
![alt text](image-8.png)
    
프로세스 B, D 실행 끝<br>
메모리 떠나면 빈 공간 생김<br>
빈 공간: 50MB<br>
BUT 50MB 크기 프로세스 적재X

</td>
<td align="center">
    
![alt text](image-9.png)
    
외부 단편화 발생

</td>
</tr>
</table>

- **외부 단편화**: 프로세스 할당하기 어려울 만큼 작은 메모리 공간들로 인해 메모리가 낭비되는 현상
  - 프로세스 B가 스왑 아웃되고 B보다 작은 D가 적재되었을 때 외부 단편화 발생
  ![외부 단편화](image-10.png)
  - 외부 단편화로 인해 낭비되는 공간 더욱 큼
- 외부 단편화 해결 방안) **압축(compaction)**
  - 메모리 조각 모음
  - 여기저기 흩어져 있는 빈 공간 하나로 모으는 방식
  ![압축](image-11.png)
  - 단점
    - 작은 빈 공간 하나로 모으는 동안 시스템은 하던 일 중지해야
    - 메모리 내용 옮기는 작업은 오버헤드 많이 야기
    - 어떤 프로세스를 어떻게 움직여야 오버헤드 최소화하며 압축할 수 있는지 명확한 방법 결정 어려움
    - 그래서 다른 해결 방안 ==> `가상 메모리 기법 中 페이징 기법` 등장

---
# 14-2. 페이징을 통한 가상 메모리 관리
- **가상 메모리(virtual memory)**: 실행하고자 하는 프로그램을 일부만 메모리에 적재해 실제 물리 메모리 크기보다 더 큰 프로세스 실행하게 하는 기술
  - 기법: 페이징, 세그멘테이션
## 14-2-1. 페이징이란
- 연속 메모리 할당에서 외부 단편화 생긴 근본적인 이유?
  각기 다른 크기의 프로세스가 메모리에 연속적으로 할당되었기 때문
  ![외부 단편화 이유](image-12.png)
  - 메모리와 프로세스 일정 단위로 자르고, 메모리에 불연속적으로 할당한다면? `외부 단편화 발생X`
  - 이것이 `Paging`
### 페이징(Paging)
- 프로세스의 논리 주소 공간을 페이지라는 일정 단위로 자르고, 메모리 물리 주소 공간을 프레임이라는 페이지와 동일한 크기의 일정한 단위로 자른 뒤, 페이지를 프레임에 할당하는 가상 메모리 관리 기법
- 페이징도 스와핑 가능
  - 프로세스 단위X, 페이지 단위로 스와핑
  - `페이지 아웃`(page out): 페이징 시스템에서의 스왑 아웃
  - `페이지 인`(page in): 페이징 시스템에서의 스왑 인
  ![페이지 스와핑](image-13.png)
  - 한 프로세스 실행하기 위해 프로세스 전체가 메모리 적재될 필요X
  - 실행에 필요 없는 페이지들은 보조기억장치에 남겨둘 수 있음
  - **물리 메모리 보다 더 큰 프로세스 실행 가능**
    ![alt text](image-14.png)

## 14-2-2. 페이지 테이블(page table)
- 프로세스에 메모리가 불연속적으로 배치되어 있다면 CPU가 순차적으로 실행X
  --> 프로세스 이루는 페이지가 어느 프레임에 적재됐는지 다 알지 못하니까
- 그래서 페이징 시스템은 프로세스가 물리 주소에 불연속적 배치되어도, 논리 주소에는 연속적으로 배치되도록 페이지 테이블 사용
  ![alt text](image-15.png)
- 페이지 테이블의 페이지 번호 통해 페이지가 적재된 프레임 찾을 수 있음
  - 페이지 번호
  - 프레임 번호
  - 유효 비트
  - 보호 비트
  - 접근 비트
  - 수정 비트 등
- 페이징은 외부 단편화 해결 But `내부 단편화` 야기할 수도
  - 모든 프로세스가 페이지 크기에 딱 맞게 잘리는 게 아니니까
  - 내부 단편화는 하나의 페이지 크기보다 작은 형태로 발생
  - 내부 단편화를 적당히 방지하면서 너무 크지 않은 페이지 테이블이 만들어지도록 페이지 크기 조정(너무 작으면 페이지 테이블 크기가 너무 커져서 공간 낭비)
  ![내부 단편화](image-16.png)
### 페이지 테이블 베이스 레지스터(PTBR; Page Table Base Register)
- 프로세스마다 각자의 프로세스 테이블 가지고 있고 각 프로세스의 페이지 테이블은 메모리에 적재
- PTBR은 각 프로세스의 페이지 테이블이 적재된 주소 가리킴
  ![PTBR](image-17.png)
- 각 프로세스들의 페이지 테이블 정보는 각 프로세스의 PCB에 기록, 프로세스 문맥 교환 시 다른 레지스터처럼 변경
<br>

![alt text](image-18.png)
- 페이지 테이블을 메모리에 두면 문제
  - 메모리 접근 시간 2배로 늘어페이지 테이블 접근; 1번
  - 프레임에 접근; 2번
### TLB(Translation Lookaside Buffer)
- 위의 문제 해결하고자 CPU 곁에(일반적으로 MMU 내) TLB라는 페이지 테이블 `캐시 메모리` 둠(TLB도 곧 캐시 메모리)
- `TLB 히트`(TLB hit): CPU가 발생한 논리 주소에 대한 페이지 번호가 TLB에 있을 경우 --> 이 경우는 페이지 적재된 프레임 알기 위해 메모리 접근할 필요X
- `TLB 미스`(TLB miss): 페이지 번호가 TLB에 없을 경우 어쩔 수 없이 페이지가 적재된 프레임 알기 위해 메모리 내 페이지 테이블에 접근하는 수밖에

## 14-2-3. 페이징에서의 주소 변환
- 특정 주소에 접근할 때 필요한 2가지 정보
  - 어떤 페이지 or 프레임 접근?
  - 접근하려는 주소가 그 페이지 or 프레임에서 얼마나 떨어져 있는지
- 그래서 페이징 시스템에서는 모든 논리 주소가 **페이지 번호(page number)**, **변위(offset)** 로 이뤄져 있음
  ![alt text](image-19.png)
    - 논리 주소 <페이지 번호, 변위>
    - 페이지 테이블을 통해 물리 주소 <프레임 번호, 변위> 로 변환
    ![alt text](image-20.png)

## 14-2-4. 페이지 테이블 엔트리(PTE; Page Table Entry)
페이지 테이블의 각가의 행들
![PTE](image-21.png)

### 유효 비트(valid bit)
- 현재 해당 페이지에 접근 가능한지 여부 알려줌
- PTE에서 프레임 번호 다음으로 중요한 정보
- 현재 페이지가 메모리에 적재되었는지, 보조기억장치에 있는지 알려줌
- `유효 비트 1`; 페이지가 메모리에 적재
- `유효 비트 0`; 페이지가 메모리에 적재X
- **페이지 폴트(page fault)**: CPU가 유효 비트 0인 페이지로 접근하려 하면 발생하는 예외
  - CPU가 페이지 폴트 처리하는 과정 (≈ HW 인터럽트 처리하는 과정)<br>
    1. CPU는 기존 작업 내역 백업
    2. 페이지 폴트 처리 루틴 실행
    3. 페이지 처리 루틴은 우너하는 페이지를 메모리로 가져온 뒤, 유효 비트 1로 변경
    4. 페이지 폴트 처리했다면 이제 CPU는 해당 페이지 접근 가능
- **보호 비트(protection bit)**: 페이지 보호 기능 위해 존재하는 비트
  - 보호 비트로 해당 페이지가 읽고 쓰기가 모두 가능한 페이지인지, 읽기만 가능한 페이지인지 나타낼 수 있음
  - `보호 비트 0`: 읽기만 가능
  - `보호 비트 1`: 읽기 쓰기 모두 가능
  - 프로세스 이루는 요소 中 코드 영역은 읽기 전용 영역
  - 읽기 전용 페이지에 쓰기 시도하면 OS가 이를 막아줌
  - 읽기(r), 쓰기(w), 실행(x) 조합으로 권한 나타낼 수 있음
    ![rwx](image-22.png)
- **참조 비트(reference bit)**: 이 페이지에 접근한 적 있는지 여부 나타냄
  - `참조 비트 1`: 적재 이후 CPU가 읽거나 쓴 페이지
  - `참조 비트 0`: 적재 이후 한번도 읽거나 쓴 적 없는 페이지
- **수정 비트(modified bit)**: 해당 페이지에 데이터 쓴 적 있는지 없는지 수정 여부 알려줌 (= 더티 비트(dirty bit))
  - `수정 비트 1`: 변경된 적 있는 페이지
  - `수정 비트 0`: 변경된 적 없는 페이지
  - 왜 수정 비트 존재?<br>
    **페이지가 메모리에서 사라질 때 보조기억장치에 쓰기 작업 해야 하는지, 할 필요 없는지 판단하기 위해서**
    - 한번도 수정한 적 없는 페이지(CPU가 접근한 적X, 읽기만, 수정 비트 0) 메모리와 보조기억장치에 같은 값 가지고 있음
    - 이런 페이지가 스왑 아웃 되면 아무런 추가 작업 없이 새로 적재된 페이지로 덮어 쓰기만 하면 됨
        ![alt text](image-23.png)
    - 수정 비트가 1인 페이지(CPU가 쓰기 작업 함)은 보조기억장치에 저장된 페이지의 내용과 메모리 저장된 페이지 내용 서로 다른 값
        ![alt text](image-24.png)
### 참고
#### 페이징 이점-쓰기 시 복사
- 페이징의 이점
  - 외부 단편화 문제 해결
  - 프로세스 간 페이지 공유
    - 공유 라이브러리 등
    - **쓰기 시 복사**(copy on write)
- 쓰기 시 복사
  - 원래 프로세스 간 자원 공유X
  - 원래는 부모 - 자식 프로세스 다르게
    ![alt text](image-25.png)
  - 동일한 프레임 가리키게 하는 게 `쓰기 시 복사`
    ![alt text](image-26.png)
  - 프로세스 생성 시간 줄이고, 메모리 공간 절약
#### 계층적 페이징(hierarchical paging)
- 프로세스 이루는 모든 PTE를 항상 메모리에 유지하지 않을 수 있는 방법
- 페이지 테이블 페이징 하여 여러 단계의 페이지 두는 방식
- 다단계 페이지 테이블(multilevel page table) 이라 부르기도
- 바깥 페이지 번호 / 안쪽 페이지 번호로 나눠서
    <table>
    <tr>
    <td align="center">
        
    ![alt text](image-27.png)
        
    계층적 페이징 안 쓸 때 논리 주소

    </td>
    <td align="center">
        
    ![alt text](image-28.png)
        
    계층적 페이징 쓸 때 형태

    </td>
    </tr>
    </table>
- 논리 주소 토대로 주소 변환 이뤄지는 과정
  ![주소 변환](image-29.png)
  1. 바깥 페이지 번호로 페이지 테이블의 페이지 찾기
  2. 페이지 테이블의 페이지를 통해 프레임 번호 찾고 변위 더함으로서 물리 주소 얻기

---
# 14-3. 페이지 교체와 프레임 할당
## 14-3-1. 요구 페이징(demand paging)
- 프로세스를 메모리에 적재할 때 처음부터 모든 페이지를 적재하지 않고 **필요한 페이지만을 메모리에 적재**하는 기법
- 요구 페이징의 기본적 양상
  1. CPU가 특정 페이지에 접근하는 명령어 실행
  2. 해당 페이지가 현재 메모리에 있으면(유효 비트 1) CPU는 페이지가 적재된 프레임에 접근
  3. 해당 페이지가 현재 메모리에 없으면(유효 비트 0) 페이지 폴트 발생
  4. 페이지 폴트 처리 루틴은 해당 페이지 메모리로 적재하고 유효 비트 1로 설정
  5. 다시 1번 수행
- 순수 요구 페이징(pure demand paging)
  - 아무런 페이지도 메모리에 적재하지 않은 채 무작정 실행부터 할 수도 있음
  - 프로세스 첫 명령어 실행하는 순간부터 페이지 폴트 계쏙 발생
  - 실행에 필요한 페이지 어느 정도 적재된 이후부터는 페이지 폴트 발생 빈도 떨어짐
- 요구 페이징 시스템이 안정적으로 작동하려면 해결해야 하는 2가지
  - 페이지 교체
  - 프레임 할당

## 14-3-2. 페이지 교체 알고리즘
- 요구 페이징 기법 하다보면 언젠가는 메모리 가득 차기 때문에 메모리에 적재된 페이지 보조 기억 장치로 내보내야 함
- 쫓아낼 페이지를 결정하는 방법
- 페이지 폴트 횟수
  - 이는 페이지 참조열(page reference string)으로 알 수 있음
  - 연속된 페이지는 생략 --> 중복 페이지 참조는 페이지 폴트 발생X
  - 페이지 교체 알고리즘에서 페이지 폴트 안 일어나면 고려할 필요가 없음
### FIFO 페이지 교체 알고리즘(First-In First-Out Page Replacement Algorithm)
- 가장 먼저 올라온 페이지부터 내쫓기
- 오래 머물렀으면 나가라!
![FIFO](image-30.png)
- 참고(2차 기회 페이지 교체 알고리즘)
  - FIFO 변형, 한 번 더 기회 주는 알고리즘
  ![alt text](image-31.png)
  ![alt text](image-32.png)
### 최적 페이지 교체 알고리즘(Optional page replacement algorithm)
- CPU에 의해 참조되는 횟수 고려
  - 자주 사용될 페이지는 메모리에 오랫동안 남아야 할 페이지
  - 오래 안 쓰는 페이지는 메모리에 오래 안 남아도 될 페이지
- 오래 메모리 있었다고 쫓으면 비합리적
- 사용 빈도 따라서!
  ![최적 페이지 교체](image-33.png)
### LRU 페이지 교체 알고리즘(LRU; Least Recently Used Page Replacement Algorithm)
- 가장 오래 안 사용된 페이지 교체
- 최근에 사용되지 않은 페이지는 앞으로도 안 사용될 것
  ![LRU](image-34.png)
## 14-3-3. 스래싱과 프레임 할당
- 페이지 폴트 자주 발생하는 이유
  - 나쁜 페이지 교체 알고리즘
  - 프로세스가 사용가능한 프레임 수가 적을 때(이게 더 근본적 이유)
### 스래싱(thrashing)
- 프로세스 실제 실행 시간 보다 페이징에 더 많은 시간 소요해서 성능 저하되는 문제
- 지나치게 빈번한 페이지 교체로 CPU 이용률 낮아지는 문제
  ![스래싱](image-35.png)
  - 멀티프로그래밍의 정도(degree of multiprogramming)
    - 정도가 높다면 현재 메모리에 많은 프로세스가 동시 실행중
    - 정도가 낮다면 현재 메모리에 적은 프로세스가 동시 실행중
    ![멀티프로그래밍의 정도](image-36.png)
    ==> 멀티프로그래밍의 정도를 늘린다고 CPU 이용률이 그에 비례X
### 프레임 할당
- 정적 할당 방식 - 단순 프로세스 크기와 물리 메모리 크기만 고려
  - **균등 할당**(equal allocation): 모든 프로세스에 동일한 프레임 배분
    - 실행되는 프로세스 크기 각각 다른데 균등한 것은 비합리적
  - **비례 할당**(proportional allocation): 프로세스 크기에 따라 프레임 배분
    - 프로세스 크기 커도 실행에 많은 프레임 안 필요할 수도, 반대일 수도
    - 하나의 프로세스가 실제로 얼마나 많은 프레임 필요한지 결국 실행해 봐야 안다
- 동적 할당 방식 - 프로세스 실행 보고 할당할 프레임 수 정함
  - **작업 집합 모델 기반** 프레임 할당 방식(working set modal allocation)
    - 작업 집합(working set): 실행 중인 프로세스가 일정 시간 동안 참조한 페이지의 집합
      - 작업 집합 구하기(2가지 필요)
        1. 프로세스 참조한 페이지
        2. 일정 시간 간격
        ![작업 집합 구하기](image-37.png)
    - 이 작업 집합을 기억하여 빈번한 페이지 교체 방지
  - **페이지 폴트율 기반** 프레임 할당 방식(PFF allocation; Page-Fault Frequency allocation)
    ![PFF](image-38.png)
    - 페이지 폴트율 高 --> 너무 적은 프레임 갖고 있음
    - 페이지 폴트율 低 --> 너무 많은 프레임 갖고 있음
    - 이에 따라 페이지 폴트율에 상한선과 하한선 정해 그 내부 범위 안에서만 프레임 할당
    - 상한선, 하한선은 임의로 그은 것

---
# Question
## Q1. TLB란 무엇인지, TLB 히트와 TLB 미스가 일어날 때 참조아 어떻게 이뤄지는지 설명해주세요.
TLB란 페이지 테이블의 캐시 메모리 역할을 수행하기 위해 페이지 테이블의 일부를 저장하는 것입니다.
TLB 히트가 일어나면 메모리를 한 번만 참조해도 무방하지만, TLB 미스가 일어나면 메모리를 2번 참조해야 합니다. 먼제 페이지 테이블에 접근하고 그 다음 실제 데이터가 있는 프레임에 접근해야 하기 때문입니다.

## Q2. 페이징이란 무엇인가요?
페이징은 프로세스의 논리 주소 공간을 '페이지'라는 일정 단위로 자르고 메모리의 물리 주소 공간을 '프레임'이라는 동일한 크기의 단위로 나눈 뒤, 페이지를 프레임에 할당하는 가상 메모리 관리 기법입니다. 이를 통해 메모리를 더 효율적으로 관리할 수 있습니다.

## Q3. 프레임이 3개이고 페이지 참조열이 `2 3 1 3 5 2 3 4 2 3` 일 경우, FIFO, 최적, LRU 페이지 교체 알고리즘 별로 몇 번의 페이지 폴트가 발생할까요?
- FIFO - 4번
- 최적 - 2번
- LRU - 3번